#include <stdio.h>
#include <stdlib.h>
#include "trajet.h"
#include "avl.c"

//structure liste des différentes villes
typedef struct{
    char ville[50];
    struct ville* pnext;
}ville;

//structure AVL
typedef struct {
    Etape a;
    int d;
    struct AVLNode *left;
    struct AVLNode *right;
    int height;
} AVLville;

// Structure pour représenter une étape
typedef struct {
    int id_trajet;
    char ville_depart[50];
    char ville_arrivee[50];
} Etape;

// Structure pour représenter une ville avec le nombre de trajets total et le nombre de départs
typedef struct {
    char nom[50];
    int trajets_total;
    int departs;
    struct Ville* pnext
} Ville;

// Structure pour représenter la distance d'une étape
typedef struct {
    int id_trajet;
    int id_etape;
    int distance;
} Distance;

//fonction insertion ville liste des villes
ville* insertionville(ville* pliste, char vil){
    if (pliste!){
        pliste->ville=vil;
        pliste->next=NULL;
        return pliste;
    }else if(pliste->ville=ville){
        exit(1);
    }else{
        pliste=pliste->next
    };
 };

//Fonction compter nombre villes diff
int nombre_chainon(ville* pliste){
    int v=0;
    while(pliste!=NULL){
        v++;
        pliste=plist->next;
    };
    return v;
};

//Fonction pour compter le nombre de noeuds départ dans un avl
int compterDépart(Noeud *racine){
    int v=0;
    if (racine != NULL && racine->d=1) {
        v++;
        parcoursInfixe(racine->gauche);
        parcoursInfixe(racine->droite);
    }else{
        parcoursInfixe(racine->gauche);
        parcoursInfixe(racine->droite);
    };
    return v;
};

// Fonction pour compter le nombre de nœuds dans un arbre AVL
int compterNoeuds(Noeud *racine) {
    if (racine == NULL) {
        return 0;
    }
    return 1 + compterNoeuds(racine->gauche) + compterNoeuds(racine->droite);
}

// ... Autres fonctions pour AVL, tri, etc.

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <option> <fichier.csv>\n", argv[0]);
        return 1;
    }

    char option = argv[1][0];
    char *fichier_csv = argv[2];

    if (option == 't') {
        FILE *fichier = fopen(fichier_csv, "r");
        if (fichier == NULL) {
            fprintf(stderr, "Erreur d'ouverture du fichier.\n");
            return 1;
        }
        Etape *p1 = NULL;
        int nombre_etapes = 0;
        while (fscanf(fichier, "%d,%49[^,],%49[^,],%d\n", &p1[nombre_etapes].id_trajet, p1[nombre_etapes].ville_depart, p1[nombre_etapes].ville_arrivee,
                      &p1[nombre_etapes].est_depart) == 4) {
            nombre_etapes++;
            p1 = realloc(p1, (nombre_etapes + 1) * sizeof(Etape));
            if (p1 == NULL) {
                fprintf(stderr, "Erreur d'allocation de mémoire.\n");
                return 1;
            }
        }
        int a=1;
        int b=0;
        ville* pliste=NULL;
        for(i=0,i<nombre_etapes,i++){
            *(p1[nombre_etapes].ville_depart)=insertAVLville(AVLville *(p1[nombre_etapes].ville_depart), Etape p1[nombre_etapes],int a);
            *(p1[nombre_etapes].ville_arrivee)=insertAVLville(AVLville *(p1[nombre_etapes].ville_arrivee), Etape p1[nombre_etapes],int b);
            pliste=insertliste(pliste,(p1[nombre_etapes].ville_depart));
            pliste=insertliste(pliste,(p1[nombre_etapes].ville_arrivee));
        };
        Ville* l1=NULL;
        int k=0;
        int l=0;
        while(pliste!=NULL){
            k=compterNoeuds(AVLville* pliste->char);
            l=compterDépart(AVLville* pliste->char);
            l1=insert_stat(l1;pliste->char,k,l);
            pliste=pliste->next;
        };
        
        
    
        // Programme suite

        free(p1);  // Libérer la mémoire allouée
        fclose(fichier);  // Fermer le fichier
    } else if (option == 's') {
        FILE *fichier = fopen(fichier_csv, "r");
        if (fichier == NULL) {
            fprintf(stderr, "Erreur d'ouverture du fichier.\n");
            return 1;
        }
        Trajet *p1 = NULL;
        int nombre_trajets = 0;
        while (fscanf(fichier, "%d,%d,%d\n", &p1[nombre_trajets].id_trajet, &p1[nombre_trajets].id_etape, &p1[nombre_trajets].est_depart) == 3) {
            nombre_trajets++;
            p1 = realloc(p1, (nombre_trajets + 1) * sizeof(Trajet));
            if (p1 == NULL) {
                fprintf(stderr, "Erreur d'allocation de mémoire.\n");
                return 1;
            }
        }
        // Programme suite

        free(p1);  // Libérer la mémoire allouée
        fclose(fichier);  // Fermer le fichier
    } else {
        fprintf(stderr, "Option non reconnue.\n");
        return 1;
    }

    return 0;
}
