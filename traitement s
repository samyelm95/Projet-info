
// Structure pour représenter la distance d'une étape
typedef struct {
    int id_trajet; 
    float distance;
} Distance;

typedef struct {
    int id_trajet;
    float distance;
    struct *min next;
} min;

typedef struct {
    int id_trajet;
    float distance;
    struct *max next;
} max;

typedef struct {
    int id_trajet;
    float distance;
    struct *moyenne next;
} moyenne;

typedef struct{
    int id;
    float moyenne;
    float max;
    float min;
    struct *trajet_stats next;
}trajet_stats;

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <option> <fichier.csv>\n", argv[0]);
        return 1;
    }

    char option = argv[1][0];
    char *fichier_csv = argv[2];
else if (option == 's') {
        FILE *fichier = fopen(fichier_csv, "r");
        if (fichier == NULL) {
            fprintf(stderr, "Erreur d'ouverture du fichier.\n");
            return 1;
        }
        Distance *p1 = NULL;
        int nombre_trajets = 0;
        while (fscanf(fichier, "%d,%f\n", &p1[nombre_trajets].id_trajet, &p1[nombre_trajets].distance) == 2) {
            nombre_trajets++;
            p1 = realloc(p1, (nombre_trajets + 1) * sizeof(Trajet));
            if (p1 == NULL) {
                fprintf(stderr, "Erreur d'allocation de mémoire.\n");
                return 1;
        
        } 
        moyenne m;
        max n;
        min p;
        for(int i=0;i<nombre_trajets;i++){
            m=insertmoy(m,p1[nombre_trajets]);
            n=insertmax(n,p1[nombre_trajets]);
            p=insertmin(p,p1[nombre_trajets]);
        };
        Trajet *liste;
        liste=insertlist(liste,m,n,p);
        AVL *ordre;
        Trajet *tmp;
        tmp=liste;
        while(tmp!=NULL){
            ordre=insertAVL(ordre,tmp);
            tmp=tmp->next;
        };
        while(nombrechainon(ordre)>50){
            ordre=supmin(ordre);
        };
        parcourinfixe(ordre);

        faire une liste chainee pour la moyenne
            une pour le min 
            une pour le max
        remplire la structure trajet_stat en lisant chacune des listes
        creer un avl trajet_stat
        retourner 50 plus grandes valeur ou supp jusqua en garder 50
        

        free(p1);  // Libérer la mémoire allouée
        fclose(fichier);  // Fermer le fichier
    } else {
        fprintf(stderr, "Option non reconnue.\n");
        return 1;
    }

    return 0;
};
